<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>allensdk.model.glif.glif_neuron_methods &mdash; Allen SDK 0.13.1 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/aibs_sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '0.13.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="top" title="Allen SDK 0.13.1 documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" /> 
  </head>
  <body role="document">
<link href="http://www.brain-map.org/assets/stylesheets/portal.css" media="screen" rel="stylesheet" type="text/css" />
<script src="http://www.brain-map.org/assets/javascripts/portal.js" type="text/javascript"></script>
<script src="http://www.brain-map.org/assets/javascripts/ga.js" type="text/javascript"></script>
<script type="text/javascript">
    var _pSupressBrowserFlashWarning = true;
    var _pTabId = "pHome";
    var _pMoreProjectsId = "pMoreProjects";
    var _pImagePath = "http://www.brain-map.org/assets/images/";
    var _pSiteWarnings = function() {
        this.show_warning() = {};
    }
</script>
<script type="text/javascript">
    function initialize() {
        /*** do your stuff, then initialize the portal plugin ***/
        _pPortalOnLoad();
    }
</script>
<style>
  #header_content > a {
  display: inline-block;
  width: 250px;
  height: 75px;
  background-image:url("/AllenSDK/_static/external_assets/images/Brain_Atlas_Logotype_SDK.png") !important;
  background-size: 235px 37px;
  background-position: 0px 20px;
  background-repeat: no-repeat;
  }
</style>

<script type="text/javascript" src="http://www.brain-map.org/external_assets/javascripts/portalHeader.js"></script>
<link rel="stylesheet" type="text/css" href="/AllenSDK/_static/external_assets/stylesheets/common_layout.css" />


  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for allensdk.model.glif.glif_neuron_methods</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; The methods in this module are used for configuring dynamics and reset rules for the GlifNeuron.  </span>
<span class="sd">For more details on how to use these methods, see :doc:`glif_models`.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>


<div class="viewcode-block" id="GlifNeuronMethod"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.GlifNeuronMethod">[docs]</a><span class="k">class</span> <span class="nc">GlifNeuronMethod</span><span class="p">(</span> <span class="nb">object</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A simple class to keep track of the name and parameters associated with a neuron method.</span>
<span class="sd">    This class is initialized with a name, function, and parameters to pass to the function.  The</span>
<span class="sd">    function then has those passed parameters fixed to a partial function using functools.partial.  </span>
<span class="sd">    This class then mimics a function itself using the __call__ convention. Parameters that are not </span>
<span class="sd">    fixed in this way are assumed to be passed into the method when it is called.  If the passed</span>
<span class="sd">    parameters contain an argument that is not part of the function signature, an exception will</span>
<span class="sd">    be raised.    </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    method_name : string</span>
<span class="sd">        A shorthand name that will be used to reference this method in the `GlifNeuron`.</span>
<span class="sd">    method : function</span>
<span class="sd">        A python function to be called when this instance is called.</span>
<span class="sd">    method_params : dict</span>
<span class="sd">        A dictionary mapping function arguments to values for values that should be fixed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">method_params</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">method_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">method_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">method_params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Defining this method allows an instance to be called like a function &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="GlifNeuronMethod.to_dict"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.GlifNeuronMethod.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s1">&#39;params&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="GlifNeuronMethod.modify_parameter"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.GlifNeuronMethod.modify_parameter">[docs]</a>    <span class="k">def</span> <span class="nf">modify_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">operator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Modify a function parameter needs to be modified after initialization. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        param : string</span>
<span class="sd">            the name of the parameter to modify</span>
<span class="sd">        operator : callable</span>
<span class="sd">            a function or lambda that returns the desired modified value</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type</span>
<span class="sd">            the new value of the variable that was just modified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">operator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">keywords</span><span class="p">[</span><span class="n">param</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">keywords</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">value</span></div></div>


<div class="viewcode-block" id="max_of_line_and_const"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.max_of_line_and_const">[docs]</a><span class="k">def</span> <span class="nf">max_of_line_and_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">):</span>
    <span class="c1">#TODO: move to other library</span>
    <span class="sd">&quot;&quot;&quot; Find the maximum of a value and a position on a line </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: float</span>
<span class="sd">        x position on line 1</span>
<span class="sd">    c: float</span>
<span class="sd">        slope of line 1</span>
<span class="sd">    d: float</span>
<span class="sd">        y-intercept of line 1</span>
<span class="sd">    b: float</span>
<span class="sd">        y-intercept of line 2</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        the max of a line value and a constant</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">one</span> <span class="o">=</span> <span class="n">b</span>
    <span class="n">two</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">d</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">one</span><span class="p">,</span><span class="n">two</span><span class="p">)</span></div>


<div class="viewcode-block" id="min_of_line_and_zero"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.min_of_line_and_zero">[docs]</a><span class="k">def</span> <span class="nf">min_of_line_and_zero</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">):</span>
    <span class="c1">#TODO: move to other library</span>
    <span class="sd">&quot;&quot;&quot; Find the minimum of a value and a position on a line </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: float</span>
<span class="sd">        x position on line 1</span>
<span class="sd">    c: float</span>
<span class="sd">        slope of line 1</span>
<span class="sd">    d: float</span>
<span class="sd">        y-intercept of line 1</span>
<span class="sd">    b: float</span>
<span class="sd">        y-intercept of line 2</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        the max of a line value and a constant</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">one</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">two</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">d</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">one</span><span class="p">,</span><span class="n">two</span><span class="p">)</span></div>


<div class="viewcode-block" id="dynamics_AScurrent_exp"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.dynamics_AScurrent_exp">[docs]</a><span class="k">def</span> <span class="nf">dynamics_AScurrent_exp</span><span class="p">(</span><span class="n">neuron</span><span class="p">,</span> <span class="n">AScurrents_t0</span><span class="p">,</span> <span class="n">time_step</span><span class="p">,</span> <span class="n">spike_time_steps</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Exponential afterspike current dynamics method takes a current at t0 and returns the current at</span>
<span class="sd">    a time step later.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">AScurrents_t0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">neuron</span><span class="o">.</span><span class="n">k</span><span class="o">*</span><span class="n">neuron</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span></div>
        

<div class="viewcode-block" id="dynamics_AScurrent_none"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.dynamics_AScurrent_none">[docs]</a><span class="k">def</span> <span class="nf">dynamics_AScurrent_none</span><span class="p">(</span><span class="n">neuron</span><span class="p">,</span> <span class="n">AScurrents_t0</span><span class="p">,</span> <span class="n">time_step</span><span class="p">,</span> <span class="n">spike_time_steps</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This method always returns zeros for the afterspike currents, regardless of input. &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">AScurrents_t0</span><span class="p">))</span></div>


<div class="viewcode-block" id="dynamics_voltage_linear_forward_euler"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.dynamics_voltage_linear_forward_euler">[docs]</a><span class="k">def</span> <span class="nf">dynamics_voltage_linear_forward_euler</span><span class="p">(</span><span class="n">neuron</span><span class="p">,</span> <span class="n">voltage_t0</span><span class="p">,</span> <span class="n">AScurrents_t0</span><span class="p">,</span> <span class="n">inj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; (TODO) Linear voltage dynamics. &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">voltage_t0</span> <span class="o">+</span> <span class="p">(</span><span class="n">inj</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">AScurrents_t0</span><span class="p">)</span> <span class="o">-</span> <span class="n">neuron</span><span class="o">.</span><span class="n">G</span> <span class="o">*</span> <span class="n">neuron</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">voltage_t0</span> <span class="o">-</span> <span class="n">neuron</span><span class="o">.</span><span class="n">El</span><span class="p">))</span> <span class="o">*</span> <span class="n">neuron</span><span class="o">.</span><span class="n">dt</span> <span class="o">/</span> <span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">C</span> <span class="o">*</span> <span class="n">neuron</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="dynamics_voltage_linear_exact"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.dynamics_voltage_linear_exact">[docs]</a><span class="k">def</span> <span class="nf">dynamics_voltage_linear_exact</span><span class="p">(</span><span class="n">neuron</span><span class="p">,</span> <span class="n">voltage_t0</span><span class="p">,</span> <span class="n">AScurrents_t0</span><span class="p">,</span> <span class="n">inj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; (TODO) Linear voltage dynamics. &quot;&quot;&quot;</span>

    <span class="n">C</span> <span class="o">=</span> <span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">C</span> <span class="o">*</span> <span class="n">neuron</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">])</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">inj</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">AScurrents_t0</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">G</span> <span class="o">*</span> <span class="n">neuron</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">]</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">g</span><span class="o">/</span><span class="n">C</span>
    <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="n">I</span><span class="o">+</span> <span class="n">g</span><span class="o">*</span><span class="n">neuron</span><span class="o">.</span><span class="n">El</span><span class="p">)</span><span class="o">/</span><span class="n">C</span>

    <span class="k">return</span> <span class="n">voltage_t0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">neuron</span><span class="o">.</span><span class="n">dt</span><span class="o">*</span><span class="n">tau</span><span class="p">)</span> <span class="o">+</span> <span class="n">N</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">tau</span><span class="o">*</span><span class="n">neuron</span><span class="o">.</span><span class="n">dt</span><span class="p">))</span><span class="o">/</span><span class="n">tau</span></div>

<div class="viewcode-block" id="spike_component_of_threshold_forward_euler"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.spike_component_of_threshold_forward_euler">[docs]</a><span class="k">def</span> <span class="nf">spike_component_of_threshold_forward_euler</span><span class="p">(</span><span class="n">th_t0</span><span class="p">,</span> <span class="n">b_spike</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Spike component of threshold modeled as an exponential decay. Implemented </span>
<span class="sd">    here for forward Euler </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    th_t0 : float</span>
<span class="sd">        threshold input to function</span>
<span class="sd">    b_spike : float</span>
<span class="sd">        decay constant of exponential</span>
<span class="sd">    dt : float</span>
<span class="sd">        time step</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">b_spike</span><span class="o">=-</span><span class="n">b_spike</span> <span class="c1">#TODO: this is here because b_spike is always input as positive although it is negative</span>
    <span class="k">return</span> <span class="n">th_t0</span> <span class="o">+</span> <span class="n">th_t0</span><span class="o">*</span><span class="n">b_spike</span> <span class="o">*</span> <span class="n">dt</span>                                                                         </div>
    
<div class="viewcode-block" id="spike_component_of_threshold_exact"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.spike_component_of_threshold_exact">[docs]</a><span class="k">def</span> <span class="nf">spike_component_of_threshold_exact</span><span class="p">(</span><span class="n">th0</span><span class="p">,</span> <span class="n">b_spike</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Spike component of threshold modeled as an exponential decay. Implemented </span>
<span class="sd">    here as exact analytical solution. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    th0 : float</span>
<span class="sd">        threshold input to function</span>
<span class="sd">    b_spike : float</span>
<span class="sd">        decay constant of exponential</span>
<span class="sd">    t : float or array</span>
<span class="sd">        time step if used in an Euler setup</span>
<span class="sd">        time if used analytically</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">b_spike</span><span class="o">=-</span><span class="n">b_spike</span>
    <span class="k">return</span> <span class="n">th0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">b_spike</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span></div>

<div class="viewcode-block" id="voltage_component_of_threshold_forward_euler"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.voltage_component_of_threshold_forward_euler">[docs]</a><span class="k">def</span> <span class="nf">voltage_component_of_threshold_forward_euler</span><span class="p">(</span><span class="n">th_t0</span><span class="p">,</span> <span class="n">v_t0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">a_voltage</span><span class="p">,</span> <span class="n">b_voltage</span><span class="p">,</span> <span class="n">El</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Equation 2.1 of Mihalas and Nieber, 2009 implemented for use in forward Euler. Note </span>
<span class="sd">    here all variables are in reference to threshold infinity.  Therefore thr_inf is zero </span>
<span class="sd">    here (replaced threshold_inf with 0 in the equation to be verbose). This is done so that </span>
<span class="sd">    th_inf can be optimized without affecting this function. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    th_t0 : float</span>
<span class="sd">        threshold input to function</span>
<span class="sd">    v_t0 : float</span>
<span class="sd">        voltage input to function</span>
<span class="sd">    dt : float</span>
<span class="sd">        time step</span>
<span class="sd">    a_voltage : float</span>
<span class="sd">        constant a</span>
<span class="sd">    b_voltage : float</span>
<span class="sd">        constant b</span>
<span class="sd">    El : float</span>
<span class="sd">        reversal potential</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">th_t0</span> <span class="o">+</span> <span class="p">(</span><span class="n">a_voltage</span><span class="o">*</span><span class="p">(</span><span class="n">v_t0</span><span class="o">-</span><span class="n">El</span><span class="p">)</span><span class="o">-</span><span class="n">b_voltage</span><span class="o">*</span><span class="p">(</span><span class="n">th_t0</span><span class="o">-</span><span class="mi">0</span><span class="p">))</span><span class="o">*</span><span class="n">dt</span></div>

<div class="viewcode-block" id="voltage_component_of_threshold_exact"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.voltage_component_of_threshold_exact">[docs]</a><span class="k">def</span> <span class="nf">voltage_component_of_threshold_exact</span><span class="p">(</span><span class="n">th0</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">a_voltage</span><span class="p">,</span> <span class="n">b_voltage</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">El</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Note this function is the exact formulation; however, dt is used because t0 is the initial time and dt</span>
<span class="sd">    is the time the function is exactly evaluated at. Note: that here, this equation is in reference to th_inf.</span>
<span class="sd">    Therefore th0 is the total threshold-thr_inf (threshold_inf replaced with 0 in the equation to be verbose).  </span>
<span class="sd">    This is done so that th_inf can be optimized without affecting this function.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    th0 : float</span>
<span class="sd">        threshold input to function</span>
<span class="sd">    v0 : float</span>
<span class="sd">        voltage input to function</span>
<span class="sd">    I : float</span>
<span class="sd">        total current entering neuron (note if there are after spike currents these must be included in this value)</span>
<span class="sd">    t : float or array</span>
<span class="sd">        time step if used in an Euler setup</span>
<span class="sd">        time if used analytically</span>
<span class="sd">    a_voltage : float</span>
<span class="sd">        constant a</span>
<span class="sd">    b_voltage : float</span>
<span class="sd">        constant b</span>
<span class="sd">    C : float</span>
<span class="sd">        capacitance</span>
<span class="sd">    g : float</span>
<span class="sd">        conductance (1/resistance)</span>
<span class="sd">    El : float </span>
<span class="sd">        reversal potential</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">beta</span><span class="o">=</span><span class="p">(</span><span class="n">I</span><span class="o">+</span><span class="n">g</span><span class="o">*</span><span class="n">El</span><span class="p">)</span><span class="o">/</span><span class="n">g</span>
    <span class="n">phi</span><span class="o">=</span><span class="n">a_voltage</span><span class="o">/</span><span class="p">(</span><span class="n">b_voltage</span><span class="o">-</span><span class="n">g</span><span class="o">/</span><span class="n">C</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">phi</span><span class="o">*</span><span class="p">(</span><span class="n">v0</span><span class="o">-</span><span class="n">beta</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">g</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">C</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">b_voltage</span><span class="o">*</span><span class="n">t</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">th0</span><span class="o">-</span><span class="n">phi</span><span class="o">*</span><span class="p">(</span><span class="n">v0</span><span class="o">-</span><span class="n">beta</span><span class="p">)</span><span class="o">-</span>
                        <span class="p">(</span><span class="n">a_voltage</span><span class="o">/</span><span class="n">b_voltage</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">beta</span><span class="o">-</span><span class="n">El</span><span class="p">)</span><span class="o">-</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span><span class="p">(</span><span class="n">a_voltage</span><span class="o">/</span><span class="n">b_voltage</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">beta</span><span class="o">-</span><span class="n">El</span><span class="p">)</span> <span class="o">+</span><span class="mi">0</span></div>


<div class="viewcode-block" id="dynamics_threshold_three_components_exact"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.dynamics_threshold_three_components_exact">[docs]</a><span class="k">def</span> <span class="nf">dynamics_threshold_three_components_exact</span><span class="p">(</span><span class="n">neuron</span><span class="p">,</span> <span class="n">threshold_t0</span><span class="p">,</span> <span class="n">voltage_t0</span><span class="p">,</span> <span class="n">AScurrents_t0</span><span class="p">,</span> <span class="n">inj</span><span class="p">,</span>
                                              <span class="n">a_spike</span><span class="p">,</span> <span class="n">b_spike</span><span class="p">,</span> <span class="n">a_voltage</span><span class="p">,</span> <span class="n">b_voltage</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Analytical solution for threshold dynamics. The threshold will adapt via two mechanisms: </span>
<span class="sd">    1. a voltage dependent adaptation.  </span>
<span class="sd">    2. a component initiated by a spike which decays as an exponential.  </span>
<span class="sd">    These two component are in reference to threshold infinity and are recorded </span>
<span class="sd">    in the neuron&#39;s threshold components.</span>
<span class="sd">    The third component refers to th_inf which is added separately as opposed to being </span>
<span class="sd">    included in the voltage component of the threshold as is done in equation 2.1 of</span>
<span class="sd">    Mihalas and Nieber 2009.  Threshold infinity is removed for simple optimization.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    neuron : class</span>
<span class="sd">    threshold_t0 : float</span>
<span class="sd">        threshold input to function</span>
<span class="sd">    voltage_t0 : float</span>
<span class="sd">        voltage input to function</span>
<span class="sd">    AScurrents_t0 : vector</span>
<span class="sd">        values of after spike currents </span>
<span class="sd">    inj : float</span>
<span class="sd">        current injected into the neuron</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#TODO: just having the get_threshold_components added an erroneous zero to the beginning of the list </span>
    <span class="k">if</span> <span class="n">neuron</span><span class="o">.</span><span class="n">threshold_components</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">neuron</span><span class="o">.</span><span class="n">threshold_components</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;spike&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;voltage&#39;</span><span class="p">:</span> <span class="p">[]</span> <span class="p">}</span>
        <span class="n">th_spike</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">th_voltage</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>                
        <span class="n">tcs</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">threshold_components</span>
        <span class="n">th_spike</span> <span class="o">=</span> <span class="n">tcs</span><span class="p">[</span><span class="s1">&#39;spike&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">th_voltage</span> <span class="o">=</span> <span class="n">tcs</span><span class="p">[</span><span class="s1">&#39;voltage&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 

    <span class="n">a_voltage</span> <span class="o">=</span> <span class="n">a_voltage</span> <span class="o">*</span> <span class="n">neuron</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
    <span class="n">b_voltage</span> <span class="o">=</span> <span class="n">b_voltage</span> <span class="o">*</span> <span class="n">neuron</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>

    <span class="n">I</span> <span class="o">=</span> <span class="n">inj</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">AScurrents_t0</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">C</span> <span class="o">*</span> <span class="n">neuron</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">G</span> <span class="o">*</span> <span class="n">neuron</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">]</span>

    <span class="n">voltage_component</span><span class="o">=</span><span class="n">voltage_component_of_threshold_exact</span><span class="p">(</span><span class="n">th_voltage</span><span class="p">,</span> <span class="n">voltage_t0</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">neuron</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">a_voltage</span><span class="p">,</span> <span class="n">b_voltage</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">neuron</span><span class="o">.</span><span class="n">El</span><span class="p">)</span>
    <span class="n">spike_component</span> <span class="o">=</span> <span class="n">spike_component_of_threshold_exact</span><span class="p">(</span><span class="n">th_spike</span><span class="p">,</span> <span class="n">b_spike</span><span class="p">,</span> <span class="n">neuron</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
 
    <span class="c1">#------update the voltage and spiking values of the the</span>
    <span class="n">neuron</span><span class="o">.</span><span class="n">append_threshold_components</span><span class="p">(</span><span class="n">spike_component</span><span class="p">,</span> <span class="n">voltage_component</span><span class="p">)</span>
     
    <span class="k">return</span> <span class="n">voltage_component</span><span class="o">+</span><span class="n">spike_component</span><span class="o">+</span><span class="n">neuron</span><span class="o">.</span><span class="n">th_inf</span> <span class="o">*</span> <span class="n">neuron</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="s1">&#39;th_inf&#39;</span><span class="p">]</span>    </div>

<div class="viewcode-block" id="dynamics_threshold_spike_component"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.dynamics_threshold_spike_component">[docs]</a><span class="k">def</span> <span class="nf">dynamics_threshold_spike_component</span><span class="p">(</span><span class="n">neuron</span><span class="p">,</span> <span class="n">threshold_t0</span><span class="p">,</span> <span class="n">voltage_t0</span><span class="p">,</span> <span class="n">AScurrents_t0</span><span class="p">,</span> <span class="n">inj</span><span class="p">,</span>
                                       <span class="n">a_spike</span><span class="p">,</span> <span class="n">b_spike</span><span class="p">,</span> <span class="n">a_voltage</span><span class="p">,</span> <span class="n">b_voltage</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Analytical solution for spike component of threshold. The threshold will adapt via </span>
<span class="sd">    a component initiated by a spike which decays as an exponential.  The component is in </span>
<span class="sd">    reference to threshold infinity and are recorded in the neuron&#39;s threshold components.  The voltage </span>
<span class="sd">    component of the threshold is set to zero in the threshold components  because it is zero here  </span>
<span class="sd">    The third component refers to th_inf which is added separately as opposed to being </span>
<span class="sd">    included in the voltage component of the threshold as is done in equation 2.1 of</span>
<span class="sd">    Mihalas and Nieber 2009.  Threshold infinity is removed for simple optimization.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    neuron : class</span>
<span class="sd">    threshold_t0 : float</span>
<span class="sd">        threshold input to function</span>
<span class="sd">    voltage_t0 : float</span>
<span class="sd">        voltage input to function</span>
<span class="sd">    AScurrents_t0 : vector</span>
<span class="sd">        values of after spike currents </span>
<span class="sd">    inj : float</span>
<span class="sd">        current injected into the neuron</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#TODO: just having the get_threshold_components added an erroneous zero to the beginning of the list </span>
    <span class="k">if</span> <span class="n">neuron</span><span class="o">.</span><span class="n">threshold_components</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">neuron</span><span class="o">.</span><span class="n">threshold_components</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;spike&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;voltage&#39;</span><span class="p">:</span> <span class="p">[]</span> <span class="p">}</span>
        <span class="n">th_spike</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">th_voltage</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>                
        <span class="n">tcs</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">threshold_components</span>
        <span class="n">th_spike</span> <span class="o">=</span> <span class="n">tcs</span><span class="p">[</span><span class="s1">&#39;spike&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">th_voltage</span> <span class="o">=</span> <span class="n">tcs</span><span class="p">[</span><span class="s1">&#39;voltage&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 

    <span class="n">spike_component</span> <span class="o">=</span> <span class="n">spike_component_of_threshold_exact</span><span class="p">(</span><span class="n">th_spike</span><span class="p">,</span> <span class="n">b_spike</span><span class="p">,</span> <span class="n">neuron</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>
 
    <span class="c1">#------update the voltage and spiking values of the the</span>
    <span class="n">neuron</span><span class="o">.</span><span class="n">append_threshold_components</span><span class="p">(</span><span class="n">spike_component</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
     
    <span class="k">return</span> <span class="n">spike_component</span><span class="o">+</span><span class="n">neuron</span><span class="o">.</span><span class="n">th_inf</span> <span class="o">*</span> <span class="n">neuron</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="s1">&#39;th_inf&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="dynamics_threshold_inf"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.dynamics_threshold_inf">[docs]</a><span class="k">def</span> <span class="nf">dynamics_threshold_inf</span><span class="p">(</span><span class="n">neuron</span><span class="p">,</span> <span class="n">threshold_t0</span><span class="p">,</span> <span class="n">voltage_t0</span><span class="p">,</span> <span class="n">AScurrents_t0</span><span class="p">,</span> <span class="n">inj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Set threshold to the neuron&#39;s instantaneous threshold. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    neuron : class</span>
<span class="sd">    threshold_t0 : not used here</span>
<span class="sd">    voltage_t0 : not used here</span>
<span class="sd">    AScurrents_t0 : not used here </span>
<span class="sd">    inj : not used here</span>
<span class="sd">    AScurrents_t0 : not used here </span>
<span class="sd">    inj : not used here</span>
<span class="sd">    &quot;&quot;&quot;</span>   
    <span class="k">return</span> <span class="n">neuron</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="s1">&#39;th_inf&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">neuron</span><span class="o">.</span><span class="n">th_inf</span></div>


<div class="viewcode-block" id="reset_AScurrent_sum"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.reset_AScurrent_sum">[docs]</a><span class="k">def</span> <span class="nf">reset_AScurrent_sum</span><span class="p">(</span><span class="n">neuron</span><span class="p">,</span> <span class="n">AScurrents_t0</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Reset afterspike currents by adding summed exponentials. Left over currents from last spikes as </span>
<span class="sd">    well as newly initiated currents from current spike.  Currents amplitudes in neuron.asc_amp_array need</span>
<span class="sd">    to be the amplitudes advanced though the spike cutting.  I.e. In the preprocessor if the after spike currents </span>
<span class="sd">    are calculated via the GLM from spike initiation the amplitude at the time after the spike cutting needs to </span>
<span class="sd">    be calculated and neuron.asc_amp_array needs to be set to this value.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : np.ndarray</span>
<span class="sd">        a coefficient vector applied to the afterspike currents</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_currents</span><span class="o">=</span><span class="n">neuron</span><span class="o">.</span><span class="n">asc_amp_array</span> <span class="o">*</span> <span class="n">neuron</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="s1">&#39;asc_amp_array&#39;</span><span class="p">]</span> <span class="c1">#neuron.asc_amp_array are amplitudes initiating after the spike is cut</span>
    <span class="n">left_over_currents</span><span class="o">=</span><span class="n">AScurrents_t0</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">k</span> <span class="o">*</span> <span class="n">neuron</span><span class="o">.</span><span class="n">dt</span> <span class="o">*</span> <span class="n">neuron</span><span class="o">.</span><span class="n">spike_cut_length</span><span class="p">))</span> <span class="c1">#advancing cut currents though the spike    </span>

    <span class="k">return</span> <span class="n">new_currents</span><span class="o">+</span><span class="n">left_over_currents</span></div>


<div class="viewcode-block" id="reset_AScurrent_none"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.reset_AScurrent_none">[docs]</a><span class="k">def</span> <span class="nf">reset_AScurrent_none</span><span class="p">(</span><span class="n">neuron</span><span class="p">,</span> <span class="n">AScurrents_t0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Reset afterspike currents to zero. &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">AScurrents_t0</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;You are running a LIF but the AScurrents are not zero!&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">AScurrents_t0</span><span class="p">))</span></div>


<div class="viewcode-block" id="reset_voltage_v_before"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.reset_voltage_v_before">[docs]</a><span class="k">def</span> <span class="nf">reset_voltage_v_before</span><span class="p">(</span><span class="n">neuron</span><span class="p">,</span> <span class="n">voltage_t0</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Reset voltage to the previous value with a scale and offset applied.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : float</span>
<span class="sd">        voltage scale constant</span>
<span class="sd">    b : float</span>
<span class="sd">        voltage offset constant</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">voltage_t0</span><span class="p">)</span><span class="o">+</span><span class="n">b</span></div>

<div class="viewcode-block" id="reset_voltage_zero"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.reset_voltage_zero">[docs]</a><span class="k">def</span> <span class="nf">reset_voltage_zero</span><span class="p">(</span><span class="n">neuron</span><span class="p">,</span> <span class="n">voltage_t0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Reset voltage to zero. &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mf">0.0</span></div>

<div class="viewcode-block" id="reset_threshold_inf"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.reset_threshold_inf">[docs]</a><span class="k">def</span> <span class="nf">reset_threshold_inf</span><span class="p">(</span><span class="n">neuron</span><span class="p">,</span> <span class="n">threshold_t0</span><span class="p">,</span> <span class="n">voltage_v1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Reset the threshold to instantaneous threshold. &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">neuron</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="s1">&#39;th_inf&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">neuron</span><span class="o">.</span><span class="n">th_inf</span></div>

<div class="viewcode-block" id="reset_threshold_three_components"><a class="viewcode-back" href="../../../../allensdk.model.glif.html#allensdk.model.glif.glif_neuron_methods.reset_threshold_three_components">[docs]</a><span class="k">def</span> <span class="nf">reset_threshold_three_components</span><span class="p">(</span><span class="n">neuron</span><span class="p">,</span> <span class="n">threshold_t0</span><span class="p">,</span> <span class="n">voltage_v1</span><span class="p">,</span> <span class="n">a_spike</span><span class="p">,</span> <span class="n">b_spike</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;This method calculates the two components of the threshold: a spike (fast)</span>
<span class="sd">    component and a voltage (slow) component.  The threshold_components vectors are then </span>
<span class="sd">    updated so that the traces match the voltage, current, and total threshold traces.  The</span>
<span class="sd">    spike component of the threshold decays via an exponential fit specified by the amplitude</span>
<span class="sd">    a_spike and the time constant b_spike fit via the multiblip data.  The voltage component </span>
<span class="sd">    does not change during the duration of the spike.  The </span>
<span class="sd">    spike component are threshold component are summed along with threshold infinity to </span>
<span class="sd">    return the total threshold.  Note that in the current implementation a_spike is added to </span>
<span class="sd">    the last value of the threshold_components which means that a_spike is the amplitude after </span>
<span class="sd">    spike cutting (if there is any).  </span>

<span class="sd">    Inputs:  </span>
<span class="sd">        neuron: class</span>
<span class="sd">            contains attributes of the neuron</span>
<span class="sd">        threshold_t0, voltage_t0: float</span>
<span class="sd">            are not used but are here for consistency with other methods</span>
<span class="sd">        a_spike: float </span>
<span class="sd">            amplitude of the exponential decay of spike component of threshold after spike</span>
<span class="sd">            cutting has been implemented.</span>
<span class="sd">        b_spike: float</span>
<span class="sd">            amplitude of the exponential decay of spike component of threshold</span>
<span class="sd">            </span>
<span class="sd">    Outputs:</span>
<span class="sd">        Returns: float</span>
<span class="sd">            the total threshold which is the sum of the spike component of threshold, the voltage </span>
<span class="sd">            component of threshold and threshold infinity (with it&#39;s corresponding coefficient)</span>
<span class="sd">        neuron.threshold_components: dictionary containing</span>
<span class="sd">            a spike: list</span>
<span class="sd">                vector of spiking component of threshold that corresponds to the voltage, current, </span>
<span class="sd">                and total threshold traces</span>
<span class="sd">            b_spike: list</span>
<span class="sd">               vector of voltage component of threshold that corresponds to the voltage, current, </span>
<span class="sd">                and total threshold traces.</span>
<span class="sd">                </span>
<span class="sd">    Note that this function can be changed to use a_spike at the time of the spike and then have the </span>
<span class="sd">    the spike component plus the residual decay thought the spike.  There are benefits and drawbacks to</span>
<span class="sd">    this.  This potential change would be beneficial as it perhaps makes more biological sense for the </span>
<span class="sd">    threshold to go up at the time of spike if the traces are ever used.  Also this would mean that a_spike</span>
<span class="sd">    would not have to be adjusted thought the spike cutting after the multiblip fit.  However the current </span>
<span class="sd">    implementation makes sense in that it is similar to how afterspike currents are implemented.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">neuron</span><span class="o">.</span><span class="n">threshold_components</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;reset should never happen at the beginning of a trace&#39;</span><span class="p">)</span>             
        
    <span class="n">tcs</span> <span class="o">=</span> <span class="n">neuron</span><span class="o">.</span><span class="n">threshold_components</span> <span class="c1">#for ease of updating</span>
    
    <span class="c1"># note that these values are at the indicie of the time of the spike which is the index right after the voltage crosses </span>
    <span class="c1"># threshold since the neuron.threshold_components are updated by the dynamics method which is called before the reset. </span>
    <span class="n">th_spike</span><span class="o">=</span><span class="n">tcs</span><span class="p">[</span><span class="s1">&#39;spike&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#this needs to decay through the spike must be very particular about how many indicies to decay</span>
    <span class="n">th_voltage</span><span class="o">=</span> <span class="n">tcs</span><span class="p">[</span><span class="s1">&#39;voltage&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># calculate spike component decay though spike from time =1 (not zero because zero is already in neuron.threshold_components</span>
    <span class="c1"># via the dynamics method) though the end of the spike cutting</span>
    <span class="n">spike_comp_decay</span><span class="o">=</span><span class="n">spike_component_of_threshold_exact</span><span class="p">(</span><span class="n">th_spike</span><span class="p">,</span> <span class="n">b_spike</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">neuron</span><span class="o">.</span><span class="n">spike_cut_length</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">neuron</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span> <span class="c1">#Note that the plus one is that one needs to know the decay and the inital condition for next starting point </span>
    
    <span class="c1">#update neuron.threshold_components via pass by reference.</span>
    <span class="p">[</span><span class="n">tcs</span><span class="p">[</span><span class="s1">&#39;voltage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">neuron</span><span class="o">.</span><span class="n">spike_cut_length</span><span class="p">)</span><span class="o">*</span><span class="n">th_voltage</span><span class="p">]</span> <span class="c1">#note that here I don&#39;t need the plus one because I am starting from zero</span>
    <span class="p">[</span><span class="n">tcs</span><span class="p">[</span><span class="s1">&#39;spike&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">spike_comp_decay</span><span class="p">]</span>
    
    <span class="c1"># add the amplitude of the spike component decay to last value of vector (reseting)</span>
    <span class="n">tcs</span><span class="p">[</span><span class="s1">&#39;spike&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">tcs</span><span class="p">[</span><span class="s1">&#39;spike&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">a_spike</span>
    
    <span class="k">return</span> <span class="n">tcs</span><span class="p">[</span><span class="s1">&#39;spike&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">tcs</span><span class="p">[</span><span class="s1">&#39;voltage&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">neuron</span><span class="o">.</span><span class="n">th_inf</span> <span class="o">*</span> <span class="n">neuron</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="s1">&#39;th_inf&#39;</span><span class="p">]</span></div>


<span class="c1">#: The METHOD_LIBRARY constant groups dynamics and reset methods by group name (e.g. &#39;voltage_dynamics_method&#39;).  </span>
<span class="c1">#Those groups assign each method in this file a string name.  This is used by the GlifNeuron when initializing </span>
<span class="c1">#its dynamics and reset methods.</span>
<span class="n">METHOD_LIBRARY</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;AScurrent_dynamics_method&#39;</span><span class="p">:</span> <span class="p">{</span> 
        <span class="s1">&#39;exp&#39;</span><span class="p">:</span>    <span class="n">dynamics_AScurrent_exp</span><span class="p">,</span>
        <span class="s1">&#39;none&#39;</span><span class="p">:</span>   <span class="n">dynamics_AScurrent_none</span>
        <span class="p">},</span>
    <span class="s1">&#39;voltage_dynamics_method&#39;</span><span class="p">:</span> <span class="p">{</span> 
        <span class="s1">&#39;linear_forward_euler&#39;</span><span class="p">:</span> <span class="n">dynamics_voltage_linear_forward_euler</span>
        <span class="p">},</span>
    <span class="s1">&#39;threshold_dynamics_method&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;spike_component&#39;</span><span class="p">:</span>        <span class="n">dynamics_threshold_spike_component</span><span class="p">,</span> 
        <span class="s1">&#39;inf&#39;</span><span class="p">:</span>                    <span class="n">dynamics_threshold_inf</span><span class="p">,</span>
        <span class="s1">&#39;three_components_exact&#39;</span><span class="p">:</span> <span class="n">dynamics_threshold_three_components_exact</span> 
        <span class="p">},</span>
    <span class="s1">&#39;AScurrent_reset_method&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;sum&#39;</span><span class="p">:</span>  <span class="n">reset_AScurrent_sum</span><span class="p">,</span>
        <span class="s1">&#39;none&#39;</span><span class="p">:</span> <span class="n">reset_AScurrent_none</span>
        <span class="p">},</span> 
    <span class="s1">&#39;voltage_reset_method&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;v_before&#39;</span><span class="p">:</span>   <span class="n">reset_voltage_v_before</span><span class="p">,</span>
        <span class="s1">&#39;zero&#39;</span><span class="p">:</span>       <span class="n">reset_voltage_zero</span>
        <span class="p">},</span> 
    <span class="s1">&#39;threshold_reset_method&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;inf&#39;</span><span class="p">:</span>              <span class="n">reset_threshold_inf</span><span class="p">,</span>
        <span class="s1">&#39;three_components&#39;</span><span class="p">:</span> <span class="n">reset_threshold_three_components</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../../../../index.html">Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../install.html">Install Guide</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../data_resources.html">Data Resources</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../brain_observatory.html">Brain Observatory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../cell_types.html">Cell Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../connectivity.html">Mouse Connectivity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../reference_space.html">Reference Space</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../data_api_client.html">API Access</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../models.html">Models</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../glif_models.html">Generalized LIF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../biophysical_models.html">Biophysical</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../allensdk.html">Source Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../allensdk.api.html">allensdk.api package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../allensdk.brain_observatory.html">allensdk.brain_observatory package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../allensdk.config.html">allensdk.config package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../allensdk.core.html">allensdk.core package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../allensdk.ephys.html">allensdk.ephys package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../allensdk.model.html">allensdk.model package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../allensdk.morphology.html">allensdk.morphology package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../allensdk.test_utilities.html">allensdk.test_utilities package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/AllenInstitute/AllenSDK">Github Profile</a></li>
</ul>

<h3> Questions </h3>
<p class="questions">
  Send any questions using the <a href="http://alleninstitute.org/contact_us/index.html">Send Us a Message</a> link below, 
  or submit your question to <a href="http://stackoverflow.com/">StackOverflow</a> using with the 'allen-sdk' tag.
</p>

<p class="questions">
  If you encounter any problems using the AllenSDK, please create an issue on <a href="http://github.com/alleninstitute/allensdk/issues/">Github's issue tracker</a>.
</p>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>


    <div class="footer" role="contentinfo">
    </div>
<script type="text/javascript" src="http://www.brain-map.org/external_assets/javascripts/portalFooter.js"></script>


  </body>
</html>